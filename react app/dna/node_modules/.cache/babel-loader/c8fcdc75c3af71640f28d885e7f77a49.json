{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactCompositeComponent\n */\n'use strict';\n\nvar ReactComponentEnvironment = require('./ReactComponentEnvironment');\n\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\n\nvar ReactElement = require('./ReactElement');\n\nvar ReactInstanceMap = require('./ReactInstanceMap');\n\nvar ReactPerf = require('./ReactPerf');\n\nvar ReactPropTypeLocations = require('./ReactPropTypeLocations');\n\nvar ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');\n\nvar ReactReconciler = require('./ReactReconciler');\n\nvar ReactUpdateQueue = require('./ReactUpdateQueue');\n\nvar assign = require('./Object.assign');\n\nvar emptyObject = require('fbjs/lib/emptyObject');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\n\nvar warning = require('fbjs/lib/warning');\n\nfunction getDeclarationErrorAddendum(component) {\n  var owner = component._currentElement._owner || null;\n\n  if (owner) {\n    var name = owner.getName();\n\n    if (name) {\n      return ' Check the render method of `' + name + '`.';\n    }\n  }\n\n  return '';\n}\n\nfunction StatelessComponent(Component) {}\n\nStatelessComponent.prototype.render = function () {\n  var Component = ReactInstanceMap.get(this)._currentElement.type;\n\n  return Component(this.props, this.context, this.updater);\n};\n/**\n * ------------------ The Life-Cycle of a Composite Component ------------------\n *\n * - constructor: Initialization of state. The instance is now retained.\n *   - componentWillMount\n *   - render\n *   - [children's constructors]\n *     - [children's componentWillMount and render]\n *     - [children's componentDidMount]\n *     - componentDidMount\n *\n *       Update Phases:\n *       - componentWillReceiveProps (only called if parent updated)\n *       - shouldComponentUpdate\n *         - componentWillUpdate\n *           - render\n *           - [children's constructors or receive props phases]\n *         - componentDidUpdate\n *\n *     - componentWillUnmount\n *     - [children's componentWillUnmount]\n *   - [children destroyed]\n * - (destroyed): The instance is now blank, released by React and ready for GC.\n *\n * -----------------------------------------------------------------------------\n */\n\n/**\n * An incrementing ID assigned to each component when it is mounted. This is\n * used to enforce the order in which `ReactUpdates` updates dirty components.\n *\n * @private\n */\n\n\nvar nextMountID = 1;\n/**\n * @lends {ReactCompositeComponent.prototype}\n */\n\nvar ReactCompositeComponentMixin = {\n  /**\n   * Base constructor for all composite component.\n   *\n   * @param {ReactElement} element\n   * @final\n   * @internal\n   */\n  construct: function (element) {\n    this._currentElement = element;\n    this._rootNodeID = null;\n    this._instance = null; // See ReactUpdateQueue\n\n    this._pendingElement = null;\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n    this._renderedComponent = null;\n    this._context = null;\n    this._mountOrder = 0;\n    this._topLevelWrapper = null; // See ReactUpdates and ReactUpdateQueue.\n\n    this._pendingCallbacks = null;\n  },\n\n  /**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: function (rootID, transaction, context) {\n    this._context = context;\n    this._mountOrder = nextMountID++;\n    this._rootNodeID = rootID;\n\n    var publicProps = this._processProps(this._currentElement.props);\n\n    var publicContext = this._processContext(context);\n\n    var Component = this._currentElement.type; // Initialize the public class\n\n    var inst;\n    var renderedElement; // This is a way to detect if Component is a stateless arrow function\n    // component, which is not newable. It might not be 100% reliable but is\n    // something we can do until we start detecting that Component extends\n    // React.Component. We already assume that typeof Component === 'function'.\n\n    var canInstantiate = 'prototype' in Component;\n\n    if (canInstantiate) {\n      if (process.env.NODE_ENV !== 'production') {\n        ReactCurrentOwner.current = this;\n\n        try {\n          inst = new Component(publicProps, publicContext, ReactUpdateQueue);\n        } finally {\n          ReactCurrentOwner.current = null;\n        }\n      } else {\n        inst = new Component(publicProps, publicContext, ReactUpdateQueue);\n      }\n    }\n\n    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {\n      renderedElement = inst;\n      inst = new StatelessComponent(Component);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // This will throw later in _renderValidatedComponent, but add an early\n      // warning now to help debugging\n      if (inst.render == null) {\n        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;\n      } else {\n        // We support ES6 inheriting from React.Component, the module pattern,\n        // and stateless components, but not ES6 classes that don't extend\n        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;\n      }\n    } // These should be set up in the constructor, but as a convenience for\n    // simpler class abstractions, we set them up after the fact.\n\n\n    inst.props = publicProps;\n    inst.context = publicContext;\n    inst.refs = emptyObject;\n    inst.updater = ReactUpdateQueue;\n    this._instance = inst; // Store a reference from the instance back to the internal representation\n\n    ReactInstanceMap.set(inst, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Since plain JS classes are defined without any special initialization\n      // logic, we can not catch common errors early. Therefore, we have to\n      // catch them here, at initialization time, instead.\n      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;\n    }\n\n    var initialState = inst.state;\n\n    if (initialState === undefined) {\n      inst.state = initialState = null;\n    }\n\n    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n\n    if (inst.componentWillMount) {\n      inst.componentWillMount(); // When mounting, calls to `setState` by `componentWillMount` will set\n      // `this._pendingStateQueue` without triggering a re-render.\n\n      if (this._pendingStateQueue) {\n        inst.state = this._processPendingState(inst.props, inst.context);\n      }\n    } // If not a stateless component, we now render\n\n\n    if (renderedElement === undefined) {\n      renderedElement = this._renderValidatedComponent();\n    }\n\n    this._renderedComponent = this._instantiateReactComponent(renderedElement);\n    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));\n\n    if (inst.componentDidMount) {\n      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);\n    }\n\n    return markup;\n  },\n\n  /**\n   * Releases any resources allocated by `mountComponent`.\n   *\n   * @final\n   * @internal\n   */\n  unmountComponent: function () {\n    var inst = this._instance;\n\n    if (inst.componentWillUnmount) {\n      inst.componentWillUnmount();\n    }\n\n    ReactReconciler.unmountComponent(this._renderedComponent);\n    this._renderedComponent = null;\n    this._instance = null; // Reset pending fields\n    // Even if this component is scheduled for another update in ReactUpdates,\n    // it would still be ignored because these fields are reset.\n\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n    this._pendingCallbacks = null;\n    this._pendingElement = null; // These fields do not really need to be reset since this object is no\n    // longer accessible.\n\n    this._context = null;\n    this._rootNodeID = null;\n    this._topLevelWrapper = null; // Delete the reference from the instance to this internal representation\n    // which allow the internals to be properly cleaned up even if the user\n    // leaks a reference to the public instance.\n\n    ReactInstanceMap.remove(inst); // Some existing components rely on inst.props even after they've been\n    // destroyed (in event handlers).\n    // TODO: inst.props = null;\n    // TODO: inst.state = null;\n    // TODO: inst.context = null;\n  },\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`\n   *\n   * @param {object} context\n   * @return {?object}\n   * @private\n   */\n  _maskContext: function (context) {\n    var maskedContext = null;\n    var Component = this._currentElement.type;\n    var contextTypes = Component.contextTypes;\n\n    if (!contextTypes) {\n      return emptyObject;\n    }\n\n    maskedContext = {};\n\n    for (var contextName in contextTypes) {\n      maskedContext[contextName] = context[contextName];\n    }\n\n    return maskedContext;\n  },\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`, and asserts that they are valid.\n   *\n   * @param {object} context\n   * @return {?object}\n   * @private\n   */\n  _processContext: function (context) {\n    var maskedContext = this._maskContext(context);\n\n    if (process.env.NODE_ENV !== 'production') {\n      var Component = this._currentElement.type;\n\n      if (Component.contextTypes) {\n        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);\n      }\n    }\n\n    return maskedContext;\n  },\n\n  /**\n   * @param {object} currentContext\n   * @return {object}\n   * @private\n   */\n  _processChildContext: function (currentContext) {\n    var Component = this._currentElement.type;\n    var inst = this._instance;\n    var childContext = inst.getChildContext && inst.getChildContext();\n\n    if (childContext) {\n      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;\n\n      if (process.env.NODE_ENV !== 'production') {\n        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);\n      }\n\n      for (var name in childContext) {\n        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;\n      }\n\n      return assign({}, currentContext, childContext);\n    }\n\n    return currentContext;\n  },\n\n  /**\n   * Processes props by setting default values for unspecified props and\n   * asserting that the props are valid. Does not mutate its argument; returns\n   * a new props object with defaults merged in.\n   *\n   * @param {object} newProps\n   * @return {object}\n   * @private\n   */\n  _processProps: function (newProps) {\n    if (process.env.NODE_ENV !== 'production') {\n      var Component = this._currentElement.type;\n\n      if (Component.propTypes) {\n        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);\n      }\n    }\n\n    return newProps;\n  },\n\n  /**\n   * Assert that the props are valid\n   *\n   * @param {object} propTypes Map of prop name to a ReactPropType\n   * @param {object} props\n   * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n   * @private\n   */\n  _checkPropTypes: function (propTypes, props, location) {\n    // TODO: Stop validating prop types here and only use the element\n    // validation.\n    var componentName = this.getName();\n\n    for (var propName in propTypes) {\n      if (propTypes.hasOwnProperty(propName)) {\n        var error;\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;\n          error = propTypes[propName](props, propName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error = ex;\n        }\n\n        if (error instanceof Error) {\n          // We may want to extend this logic for similar errors in\n          // top-level render calls, so I'm abstracting it away into\n          // a function to minimize refactoring in the future\n          var addendum = getDeclarationErrorAddendum(this);\n\n          if (location === ReactPropTypeLocations.prop) {\n            // Preface gives us something to blacklist in warning module\n            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;\n          } else {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;\n          }\n        }\n      }\n    }\n  },\n  receiveComponent: function (nextElement, transaction, nextContext) {\n    var prevElement = this._currentElement;\n    var prevContext = this._context;\n    this._pendingElement = null;\n    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);\n  },\n\n  /**\n   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`\n   * is set, update the component.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  performUpdateIfNecessary: function (transaction) {\n    if (this._pendingElement != null) {\n      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);\n    }\n\n    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {\n      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);\n    }\n  },\n\n  /**\n   * Perform an update to a mounted component. The componentWillReceiveProps and\n   * shouldComponentUpdate methods are called, then (assuming the update isn't\n   * skipped) the remaining update lifecycle methods are called and the DOM\n   * representation is updated.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevParentElement\n   * @param {ReactElement} nextParentElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {\n    var inst = this._instance;\n    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);\n    var nextProps; // Distinguish between a props update versus a simple state update\n\n    if (prevParentElement === nextParentElement) {\n      // Skip checking prop types again -- we don't read inst.props to avoid\n      // warning for DOM component props in this upgrade\n      nextProps = nextParentElement.props;\n    } else {\n      nextProps = this._processProps(nextParentElement.props); // An update here will schedule an update but immediately set\n      // _pendingStateQueue which will ensure that any state updates gets\n      // immediately reconciled instead of waiting for the next batch.\n\n      if (inst.componentWillReceiveProps) {\n        inst.componentWillReceiveProps(nextProps, nextContext);\n      }\n    }\n\n    var nextState = this._processPendingState(nextProps, nextContext);\n\n    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;\n    }\n\n    if (shouldUpdate) {\n      this._pendingForceUpdate = false; // Will set `this.props`, `this.state` and `this.context`.\n\n      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);\n    } else {\n      // If it's determined that a component should not update, we still want\n      // to set props and state but we shortcut the rest of the update.\n      this._currentElement = nextParentElement;\n      this._context = nextUnmaskedContext;\n      inst.props = nextProps;\n      inst.state = nextState;\n      inst.context = nextContext;\n    }\n  },\n  _processPendingState: function (props, context) {\n    var inst = this._instance;\n    var queue = this._pendingStateQueue;\n    var replace = this._pendingReplaceState;\n    this._pendingReplaceState = false;\n    this._pendingStateQueue = null;\n\n    if (!queue) {\n      return inst.state;\n    }\n\n    if (replace && queue.length === 1) {\n      return queue[0];\n    }\n\n    var nextState = assign({}, replace ? queue[0] : inst.state);\n\n    for (var i = replace ? 1 : 0; i < queue.length; i++) {\n      var partial = queue[i];\n      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);\n    }\n\n    return nextState;\n  },\n\n  /**\n   * Merges new props and state, notifies delegate methods of update and\n   * performs update.\n   *\n   * @param {ReactElement} nextElement Next element\n   * @param {object} nextProps Next public object to set as properties.\n   * @param {?object} nextState Next object to set as state.\n   * @param {?object} nextContext Next public object to set as context.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {?object} unmaskedContext\n   * @private\n   */\n  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {\n    var inst = this._instance;\n    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);\n    var prevProps;\n    var prevState;\n    var prevContext;\n\n    if (hasComponentDidUpdate) {\n      prevProps = inst.props;\n      prevState = inst.state;\n      prevContext = inst.context;\n    }\n\n    if (inst.componentWillUpdate) {\n      inst.componentWillUpdate(nextProps, nextState, nextContext);\n    }\n\n    this._currentElement = nextElement;\n    this._context = unmaskedContext;\n    inst.props = nextProps;\n    inst.state = nextState;\n    inst.context = nextContext;\n\n    this._updateRenderedComponent(transaction, unmaskedContext);\n\n    if (hasComponentDidUpdate) {\n      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);\n    }\n  },\n\n  /**\n   * Call the component's `render` method and update the DOM accordingly.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  _updateRenderedComponent: function (transaction, context) {\n    var prevComponentInstance = this._renderedComponent;\n    var prevRenderedElement = prevComponentInstance._currentElement;\n\n    var nextRenderedElement = this._renderValidatedComponent();\n\n    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));\n    } else {\n      // These two IDs are actually the same! But nothing should rely on that.\n      var thisID = this._rootNodeID;\n      var prevComponentID = prevComponentInstance._rootNodeID;\n      ReactReconciler.unmountComponent(prevComponentInstance);\n      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);\n      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));\n\n      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {\n    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);\n  },\n\n  /**\n   * @protected\n   */\n  _renderValidatedComponentWithoutOwnerOrContext: function () {\n    var inst = this._instance;\n    var renderedComponent = inst.render();\n\n    if (process.env.NODE_ENV !== 'production') {\n      // We allow auto-mocks to proceed as if they're returning null.\n      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {\n        // This is probably bad practice. Consider warning here and\n        // deprecating this convenience.\n        renderedComponent = null;\n      }\n    }\n\n    return renderedComponent;\n  },\n\n  /**\n   * @private\n   */\n  _renderValidatedComponent: function () {\n    var renderedComponent;\n    ReactCurrentOwner.current = this;\n\n    try {\n      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();\n    } finally {\n      ReactCurrentOwner.current = null;\n    }\n\n    !( // TODO: An `isValidNode` function would probably be more appropriate\n    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;\n    return renderedComponent;\n  },\n\n  /**\n   * Lazily allocates the refs object and stores `component` as `ref`.\n   *\n   * @param {string} ref Reference name.\n   * @param {component} component Component to store as `ref`.\n   * @final\n   * @private\n   */\n  attachRef: function (ref, component) {\n    var inst = this.getPublicInstance();\n    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;\n    var publicComponentInstance = component.getPublicInstance();\n\n    if (process.env.NODE_ENV !== 'production') {\n      var componentName = component && component.getName ? component.getName() : 'a component';\n      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref \"%s\" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;\n    }\n\n    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n    refs[ref] = publicComponentInstance;\n  },\n\n  /**\n   * Detaches a reference name.\n   *\n   * @param {string} ref Name to dereference.\n   * @final\n   * @private\n   */\n  detachRef: function (ref) {\n    var refs = this.getPublicInstance().refs;\n    delete refs[ref];\n  },\n\n  /**\n   * Get a text description of the component that can be used to identify it\n   * in error messages.\n   * @return {string} The name or null.\n   * @internal\n   */\n  getName: function () {\n    var type = this._currentElement.type;\n    var constructor = this._instance && this._instance.constructor;\n    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;\n  },\n\n  /**\n   * Get the publicly accessible representation of this component - i.e. what\n   * is exposed by refs and returned by render. Can be null for stateless\n   * components.\n   *\n   * @return {ReactComponent} the public component instance.\n   * @internal\n   */\n  getPublicInstance: function () {\n    var inst = this._instance;\n\n    if (inst instanceof StatelessComponent) {\n      return null;\n    }\n\n    return inst;\n  },\n  // Stub\n  _instantiateReactComponent: null\n};\nReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {\n  mountComponent: 'mountComponent',\n  updateComponent: 'updateComponent',\n  _renderValidatedComponent: '_renderValidatedComponent'\n});\nvar ReactCompositeComponent = {\n  Mixin: ReactCompositeComponentMixin\n};\nmodule.exports = ReactCompositeComponent;","map":{"version":3,"sources":["C:/Users/icom/myProjects/DNA/react app/dna/node_modules/react-holder/node_modules/react/lib/ReactCompositeComponent.js"],"names":["ReactComponentEnvironment","require","ReactCurrentOwner","ReactElement","ReactInstanceMap","ReactPerf","ReactPropTypeLocations","ReactPropTypeLocationNames","ReactReconciler","ReactUpdateQueue","assign","emptyObject","invariant","shouldUpdateReactComponent","warning","getDeclarationErrorAddendum","component","owner","_currentElement","_owner","name","getName","StatelessComponent","Component","prototype","render","get","type","props","context","updater","nextMountID","ReactCompositeComponentMixin","construct","element","_rootNodeID","_instance","_pendingElement","_pendingStateQueue","_pendingReplaceState","_pendingForceUpdate","_renderedComponent","_context","_mountOrder","_topLevelWrapper","_pendingCallbacks","mountComponent","rootID","transaction","publicProps","_processProps","publicContext","_processContext","inst","renderedElement","canInstantiate","process","env","NODE_ENV","current","isValidElement","displayName","undefined","isReactComponent","refs","set","getInitialState","isReactClassApproved","getDefaultProps","propTypes","contextTypes","componentShouldUpdate","componentDidUnmount","componentWillRecieveProps","initialState","state","Array","isArray","componentWillMount","_processPendingState","_renderValidatedComponent","_instantiateReactComponent","markup","_processChildContext","componentDidMount","getReactMountReady","enqueue","unmountComponent","componentWillUnmount","remove","_maskContext","maskedContext","contextName","_checkPropTypes","currentContext","childContext","getChildContext","childContextTypes","newProps","prop","location","componentName","propName","hasOwnProperty","error","ex","Error","addendum","message","receiveComponent","nextElement","nextContext","prevElement","prevContext","updateComponent","performUpdateIfNecessary","prevParentElement","nextParentElement","prevUnmaskedContext","nextUnmaskedContext","nextProps","componentWillReceiveProps","nextState","shouldUpdate","shouldComponentUpdate","_performComponentUpdate","queue","replace","length","i","partial","call","unmaskedContext","hasComponentDidUpdate","Boolean","componentDidUpdate","prevProps","prevState","componentWillUpdate","_updateRenderedComponent","bind","prevComponentInstance","prevRenderedElement","nextRenderedElement","thisID","prevComponentID","nextMarkup","_replaceNodeWithMarkupByID","replaceNodeWithMarkupByID","_renderValidatedComponentWithoutOwnerOrContext","renderedComponent","_isMockFunction","attachRef","ref","getPublicInstance","publicComponentInstance","detachRef","constructor","measureMethods","ReactCompositeComponent","Mixin","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactCompositeComponent\n */\n\n'use strict';\n\nvar ReactComponentEnvironment = require('./ReactComponentEnvironment');\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\nvar ReactElement = require('./ReactElement');\nvar ReactInstanceMap = require('./ReactInstanceMap');\nvar ReactPerf = require('./ReactPerf');\nvar ReactPropTypeLocations = require('./ReactPropTypeLocations');\nvar ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');\nvar ReactReconciler = require('./ReactReconciler');\nvar ReactUpdateQueue = require('./ReactUpdateQueue');\n\nvar assign = require('./Object.assign');\nvar emptyObject = require('fbjs/lib/emptyObject');\nvar invariant = require('fbjs/lib/invariant');\nvar shouldUpdateReactComponent = require('./shouldUpdateReactComponent');\nvar warning = require('fbjs/lib/warning');\n\nfunction getDeclarationErrorAddendum(component) {\n  var owner = component._currentElement._owner || null;\n  if (owner) {\n    var name = owner.getName();\n    if (name) {\n      return ' Check the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nfunction StatelessComponent(Component) {}\nStatelessComponent.prototype.render = function () {\n  var Component = ReactInstanceMap.get(this)._currentElement.type;\n  return Component(this.props, this.context, this.updater);\n};\n\n/**\n * ------------------ The Life-Cycle of a Composite Component ------------------\n *\n * - constructor: Initialization of state. The instance is now retained.\n *   - componentWillMount\n *   - render\n *   - [children's constructors]\n *     - [children's componentWillMount and render]\n *     - [children's componentDidMount]\n *     - componentDidMount\n *\n *       Update Phases:\n *       - componentWillReceiveProps (only called if parent updated)\n *       - shouldComponentUpdate\n *         - componentWillUpdate\n *           - render\n *           - [children's constructors or receive props phases]\n *         - componentDidUpdate\n *\n *     - componentWillUnmount\n *     - [children's componentWillUnmount]\n *   - [children destroyed]\n * - (destroyed): The instance is now blank, released by React and ready for GC.\n *\n * -----------------------------------------------------------------------------\n */\n\n/**\n * An incrementing ID assigned to each component when it is mounted. This is\n * used to enforce the order in which `ReactUpdates` updates dirty components.\n *\n * @private\n */\nvar nextMountID = 1;\n\n/**\n * @lends {ReactCompositeComponent.prototype}\n */\nvar ReactCompositeComponentMixin = {\n\n  /**\n   * Base constructor for all composite component.\n   *\n   * @param {ReactElement} element\n   * @final\n   * @internal\n   */\n  construct: function (element) {\n    this._currentElement = element;\n    this._rootNodeID = null;\n    this._instance = null;\n\n    // See ReactUpdateQueue\n    this._pendingElement = null;\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n\n    this._renderedComponent = null;\n\n    this._context = null;\n    this._mountOrder = 0;\n    this._topLevelWrapper = null;\n\n    // See ReactUpdates and ReactUpdateQueue.\n    this._pendingCallbacks = null;\n  },\n\n  /**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: function (rootID, transaction, context) {\n    this._context = context;\n    this._mountOrder = nextMountID++;\n    this._rootNodeID = rootID;\n\n    var publicProps = this._processProps(this._currentElement.props);\n    var publicContext = this._processContext(context);\n\n    var Component = this._currentElement.type;\n\n    // Initialize the public class\n    var inst;\n    var renderedElement;\n\n    // This is a way to detect if Component is a stateless arrow function\n    // component, which is not newable. It might not be 100% reliable but is\n    // something we can do until we start detecting that Component extends\n    // React.Component. We already assume that typeof Component === 'function'.\n    var canInstantiate = ('prototype' in Component);\n\n    if (canInstantiate) {\n      if (process.env.NODE_ENV !== 'production') {\n        ReactCurrentOwner.current = this;\n        try {\n          inst = new Component(publicProps, publicContext, ReactUpdateQueue);\n        } finally {\n          ReactCurrentOwner.current = null;\n        }\n      } else {\n        inst = new Component(publicProps, publicContext, ReactUpdateQueue);\n      }\n    }\n\n    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {\n      renderedElement = inst;\n      inst = new StatelessComponent(Component);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // This will throw later in _renderValidatedComponent, but add an early\n      // warning now to help debugging\n      if (inst.render == null) {\n        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;\n      } else {\n        // We support ES6 inheriting from React.Component, the module pattern,\n        // and stateless components, but not ES6 classes that don't extend\n        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;\n      }\n    }\n\n    // These should be set up in the constructor, but as a convenience for\n    // simpler class abstractions, we set them up after the fact.\n    inst.props = publicProps;\n    inst.context = publicContext;\n    inst.refs = emptyObject;\n    inst.updater = ReactUpdateQueue;\n\n    this._instance = inst;\n\n    // Store a reference from the instance back to the internal representation\n    ReactInstanceMap.set(inst, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Since plain JS classes are defined without any special initialization\n      // logic, we can not catch common errors early. Therefore, we have to\n      // catch them here, at initialization time, instead.\n      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;\n      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;\n    }\n\n    var initialState = inst.state;\n    if (initialState === undefined) {\n      inst.state = initialState = null;\n    }\n    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;\n\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n\n    if (inst.componentWillMount) {\n      inst.componentWillMount();\n      // When mounting, calls to `setState` by `componentWillMount` will set\n      // `this._pendingStateQueue` without triggering a re-render.\n      if (this._pendingStateQueue) {\n        inst.state = this._processPendingState(inst.props, inst.context);\n      }\n    }\n\n    // If not a stateless component, we now render\n    if (renderedElement === undefined) {\n      renderedElement = this._renderValidatedComponent();\n    }\n\n    this._renderedComponent = this._instantiateReactComponent(renderedElement);\n\n    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));\n    if (inst.componentDidMount) {\n      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);\n    }\n\n    return markup;\n  },\n\n  /**\n   * Releases any resources allocated by `mountComponent`.\n   *\n   * @final\n   * @internal\n   */\n  unmountComponent: function () {\n    var inst = this._instance;\n\n    if (inst.componentWillUnmount) {\n      inst.componentWillUnmount();\n    }\n\n    ReactReconciler.unmountComponent(this._renderedComponent);\n    this._renderedComponent = null;\n    this._instance = null;\n\n    // Reset pending fields\n    // Even if this component is scheduled for another update in ReactUpdates,\n    // it would still be ignored because these fields are reset.\n    this._pendingStateQueue = null;\n    this._pendingReplaceState = false;\n    this._pendingForceUpdate = false;\n    this._pendingCallbacks = null;\n    this._pendingElement = null;\n\n    // These fields do not really need to be reset since this object is no\n    // longer accessible.\n    this._context = null;\n    this._rootNodeID = null;\n    this._topLevelWrapper = null;\n\n    // Delete the reference from the instance to this internal representation\n    // which allow the internals to be properly cleaned up even if the user\n    // leaks a reference to the public instance.\n    ReactInstanceMap.remove(inst);\n\n    // Some existing components rely on inst.props even after they've been\n    // destroyed (in event handlers).\n    // TODO: inst.props = null;\n    // TODO: inst.state = null;\n    // TODO: inst.context = null;\n  },\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`\n   *\n   * @param {object} context\n   * @return {?object}\n   * @private\n   */\n  _maskContext: function (context) {\n    var maskedContext = null;\n    var Component = this._currentElement.type;\n    var contextTypes = Component.contextTypes;\n    if (!contextTypes) {\n      return emptyObject;\n    }\n    maskedContext = {};\n    for (var contextName in contextTypes) {\n      maskedContext[contextName] = context[contextName];\n    }\n    return maskedContext;\n  },\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`, and asserts that they are valid.\n   *\n   * @param {object} context\n   * @return {?object}\n   * @private\n   */\n  _processContext: function (context) {\n    var maskedContext = this._maskContext(context);\n    if (process.env.NODE_ENV !== 'production') {\n      var Component = this._currentElement.type;\n      if (Component.contextTypes) {\n        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);\n      }\n    }\n    return maskedContext;\n  },\n\n  /**\n   * @param {object} currentContext\n   * @return {object}\n   * @private\n   */\n  _processChildContext: function (currentContext) {\n    var Component = this._currentElement.type;\n    var inst = this._instance;\n    var childContext = inst.getChildContext && inst.getChildContext();\n    if (childContext) {\n      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;\n      if (process.env.NODE_ENV !== 'production') {\n        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);\n      }\n      for (var name in childContext) {\n        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;\n      }\n      return assign({}, currentContext, childContext);\n    }\n    return currentContext;\n  },\n\n  /**\n   * Processes props by setting default values for unspecified props and\n   * asserting that the props are valid. Does not mutate its argument; returns\n   * a new props object with defaults merged in.\n   *\n   * @param {object} newProps\n   * @return {object}\n   * @private\n   */\n  _processProps: function (newProps) {\n    if (process.env.NODE_ENV !== 'production') {\n      var Component = this._currentElement.type;\n      if (Component.propTypes) {\n        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);\n      }\n    }\n    return newProps;\n  },\n\n  /**\n   * Assert that the props are valid\n   *\n   * @param {object} propTypes Map of prop name to a ReactPropType\n   * @param {object} props\n   * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n   * @private\n   */\n  _checkPropTypes: function (propTypes, props, location) {\n    // TODO: Stop validating prop types here and only use the element\n    // validation.\n    var componentName = this.getName();\n    for (var propName in propTypes) {\n      if (propTypes.hasOwnProperty(propName)) {\n        var error;\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;\n          error = propTypes[propName](props, propName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error = ex;\n        }\n        if (error instanceof Error) {\n          // We may want to extend this logic for similar errors in\n          // top-level render calls, so I'm abstracting it away into\n          // a function to minimize refactoring in the future\n          var addendum = getDeclarationErrorAddendum(this);\n\n          if (location === ReactPropTypeLocations.prop) {\n            // Preface gives us something to blacklist in warning module\n            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;\n          } else {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;\n          }\n        }\n      }\n    }\n  },\n\n  receiveComponent: function (nextElement, transaction, nextContext) {\n    var prevElement = this._currentElement;\n    var prevContext = this._context;\n\n    this._pendingElement = null;\n\n    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);\n  },\n\n  /**\n   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`\n   * is set, update the component.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  performUpdateIfNecessary: function (transaction) {\n    if (this._pendingElement != null) {\n      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);\n    }\n\n    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {\n      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);\n    }\n  },\n\n  /**\n   * Perform an update to a mounted component. The componentWillReceiveProps and\n   * shouldComponentUpdate methods are called, then (assuming the update isn't\n   * skipped) the remaining update lifecycle methods are called and the DOM\n   * representation is updated.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevParentElement\n   * @param {ReactElement} nextParentElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {\n    var inst = this._instance;\n\n    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);\n    var nextProps;\n\n    // Distinguish between a props update versus a simple state update\n    if (prevParentElement === nextParentElement) {\n      // Skip checking prop types again -- we don't read inst.props to avoid\n      // warning for DOM component props in this upgrade\n      nextProps = nextParentElement.props;\n    } else {\n      nextProps = this._processProps(nextParentElement.props);\n      // An update here will schedule an update but immediately set\n      // _pendingStateQueue which will ensure that any state updates gets\n      // immediately reconciled instead of waiting for the next batch.\n\n      if (inst.componentWillReceiveProps) {\n        inst.componentWillReceiveProps(nextProps, nextContext);\n      }\n    }\n\n    var nextState = this._processPendingState(nextProps, nextContext);\n\n    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);\n\n    if (process.env.NODE_ENV !== 'production') {\n      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;\n    }\n\n    if (shouldUpdate) {\n      this._pendingForceUpdate = false;\n      // Will set `this.props`, `this.state` and `this.context`.\n      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);\n    } else {\n      // If it's determined that a component should not update, we still want\n      // to set props and state but we shortcut the rest of the update.\n      this._currentElement = nextParentElement;\n      this._context = nextUnmaskedContext;\n      inst.props = nextProps;\n      inst.state = nextState;\n      inst.context = nextContext;\n    }\n  },\n\n  _processPendingState: function (props, context) {\n    var inst = this._instance;\n    var queue = this._pendingStateQueue;\n    var replace = this._pendingReplaceState;\n    this._pendingReplaceState = false;\n    this._pendingStateQueue = null;\n\n    if (!queue) {\n      return inst.state;\n    }\n\n    if (replace && queue.length === 1) {\n      return queue[0];\n    }\n\n    var nextState = assign({}, replace ? queue[0] : inst.state);\n    for (var i = replace ? 1 : 0; i < queue.length; i++) {\n      var partial = queue[i];\n      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);\n    }\n\n    return nextState;\n  },\n\n  /**\n   * Merges new props and state, notifies delegate methods of update and\n   * performs update.\n   *\n   * @param {ReactElement} nextElement Next element\n   * @param {object} nextProps Next public object to set as properties.\n   * @param {?object} nextState Next object to set as state.\n   * @param {?object} nextContext Next public object to set as context.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {?object} unmaskedContext\n   * @private\n   */\n  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {\n    var inst = this._instance;\n\n    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);\n    var prevProps;\n    var prevState;\n    var prevContext;\n    if (hasComponentDidUpdate) {\n      prevProps = inst.props;\n      prevState = inst.state;\n      prevContext = inst.context;\n    }\n\n    if (inst.componentWillUpdate) {\n      inst.componentWillUpdate(nextProps, nextState, nextContext);\n    }\n\n    this._currentElement = nextElement;\n    this._context = unmaskedContext;\n    inst.props = nextProps;\n    inst.state = nextState;\n    inst.context = nextContext;\n\n    this._updateRenderedComponent(transaction, unmaskedContext);\n\n    if (hasComponentDidUpdate) {\n      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);\n    }\n  },\n\n  /**\n   * Call the component's `render` method and update the DOM accordingly.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  _updateRenderedComponent: function (transaction, context) {\n    var prevComponentInstance = this._renderedComponent;\n    var prevRenderedElement = prevComponentInstance._currentElement;\n    var nextRenderedElement = this._renderValidatedComponent();\n    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));\n    } else {\n      // These two IDs are actually the same! But nothing should rely on that.\n      var thisID = this._rootNodeID;\n      var prevComponentID = prevComponentInstance._rootNodeID;\n      ReactReconciler.unmountComponent(prevComponentInstance);\n\n      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);\n      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));\n      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);\n    }\n  },\n\n  /**\n   * @protected\n   */\n  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {\n    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);\n  },\n\n  /**\n   * @protected\n   */\n  _renderValidatedComponentWithoutOwnerOrContext: function () {\n    var inst = this._instance;\n    var renderedComponent = inst.render();\n    if (process.env.NODE_ENV !== 'production') {\n      // We allow auto-mocks to proceed as if they're returning null.\n      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {\n        // This is probably bad practice. Consider warning here and\n        // deprecating this convenience.\n        renderedComponent = null;\n      }\n    }\n\n    return renderedComponent;\n  },\n\n  /**\n   * @private\n   */\n  _renderValidatedComponent: function () {\n    var renderedComponent;\n    ReactCurrentOwner.current = this;\n    try {\n      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();\n    } finally {\n      ReactCurrentOwner.current = null;\n    }\n    !(\n    // TODO: An `isValidNode` function would probably be more appropriate\n    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;\n    return renderedComponent;\n  },\n\n  /**\n   * Lazily allocates the refs object and stores `component` as `ref`.\n   *\n   * @param {string} ref Reference name.\n   * @param {component} component Component to store as `ref`.\n   * @final\n   * @private\n   */\n  attachRef: function (ref, component) {\n    var inst = this.getPublicInstance();\n    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;\n    var publicComponentInstance = component.getPublicInstance();\n    if (process.env.NODE_ENV !== 'production') {\n      var componentName = component && component.getName ? component.getName() : 'a component';\n      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref \"%s\" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;\n    }\n    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n    refs[ref] = publicComponentInstance;\n  },\n\n  /**\n   * Detaches a reference name.\n   *\n   * @param {string} ref Name to dereference.\n   * @final\n   * @private\n   */\n  detachRef: function (ref) {\n    var refs = this.getPublicInstance().refs;\n    delete refs[ref];\n  },\n\n  /**\n   * Get a text description of the component that can be used to identify it\n   * in error messages.\n   * @return {string} The name or null.\n   * @internal\n   */\n  getName: function () {\n    var type = this._currentElement.type;\n    var constructor = this._instance && this._instance.constructor;\n    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;\n  },\n\n  /**\n   * Get the publicly accessible representation of this component - i.e. what\n   * is exposed by refs and returned by render. Can be null for stateless\n   * components.\n   *\n   * @return {ReactComponent} the public component instance.\n   * @internal\n   */\n  getPublicInstance: function () {\n    var inst = this._instance;\n    if (inst instanceof StatelessComponent) {\n      return null;\n    }\n    return inst;\n  },\n\n  // Stub\n  _instantiateReactComponent: null\n\n};\n\nReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {\n  mountComponent: 'mountComponent',\n  updateComponent: 'updateComponent',\n  _renderValidatedComponent: '_renderValidatedComponent'\n});\n\nvar ReactCompositeComponent = {\n\n  Mixin: ReactCompositeComponentMixin\n\n};\n\nmodule.exports = ReactCompositeComponent;"]},"metadata":{},"sourceType":"script"}