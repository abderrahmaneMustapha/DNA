{"ast":null,"code":"/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactNoopUpdateQueue\n */\n'use strict';\n\nvar warning = require('fbjs/lib/warning');\n\nfunction warnTDZ(publicInstance, callerName) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;\n  }\n}\n/**\n * This is the abstract API for an update queue.\n */\n\n\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @internal\n   */\n  enqueueCallback: function (publicInstance, callback) {},\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance) {\n    warnTDZ(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState) {\n    warnTDZ(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState) {\n    warnTDZ(publicInstance, 'setState');\n  },\n\n  /**\n   * Sets a subset of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialProps Subset of the next props.\n   * @internal\n   */\n  enqueueSetProps: function (publicInstance, partialProps) {\n    warnTDZ(publicInstance, 'setProps');\n  },\n\n  /**\n   * Replaces all of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} props New props.\n   * @internal\n   */\n  enqueueReplaceProps: function (publicInstance, props) {\n    warnTDZ(publicInstance, 'replaceProps');\n  }\n};\nmodule.exports = ReactNoopUpdateQueue;","map":{"version":3,"sources":["C:/Users/icom/myProjects/DNA/react app/dna/node_modules/react-holder/node_modules/react/lib/ReactNoopUpdateQueue.js"],"names":["warning","require","warnTDZ","publicInstance","callerName","process","env","NODE_ENV","constructor","displayName","undefined","ReactNoopUpdateQueue","isMounted","enqueueCallback","callback","enqueueForceUpdate","enqueueReplaceState","completeState","enqueueSetState","partialState","enqueueSetProps","partialProps","enqueueReplaceProps","props","module","exports"],"mappings":"AAAA;;;;;;;;;;AAWA;;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,kBAAD,CAArB;;AAEA,SAASC,OAAT,CAAiBC,cAAjB,EAAiCC,UAAjC,EAA6C;AAC3C,MAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCF,IAAAA,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwCP,OAAO,CAAC,KAAD,EAAQ,+DAA+D,gEAA/D,GAAkI,8DAA1I,EAA0MI,UAA1M,EAAsNA,UAAtN,EAAkOD,cAAc,CAACK,WAAf,IAA8BL,cAAc,CAACK,WAAf,CAA2BC,WAAzD,IAAwE,EAA1S,CAA/C,GAA+VC,SAA/V;AACD;AACF;AAED;;;;;AAGA,IAAIC,oBAAoB,GAAG;AAEzB;;;;;;;AAOAC,EAAAA,SAAS,EAAE,UAAUT,cAAV,EAA0B;AACnC,WAAO,KAAP;AACD,GAXwB;;AAazB;;;;;;;;AAQAU,EAAAA,eAAe,EAAE,UAAUV,cAAV,EAA0BW,QAA1B,EAAoC,CAAE,CArB9B;;AAuBzB;;;;;;;;;;;;;AAaAC,EAAAA,kBAAkB,EAAE,UAAUZ,cAAV,EAA0B;AAC5CD,IAAAA,OAAO,CAACC,cAAD,EAAiB,aAAjB,CAAP;AACD,GAtCwB;;AAwCzB;;;;;;;;;;;AAWAa,EAAAA,mBAAmB,EAAE,UAAUb,cAAV,EAA0Bc,aAA1B,EAAyC;AAC5Df,IAAAA,OAAO,CAACC,cAAD,EAAiB,cAAjB,CAAP;AACD,GArDwB;;AAuDzB;;;;;;;;;;AAUAe,EAAAA,eAAe,EAAE,UAAUf,cAAV,EAA0BgB,YAA1B,EAAwC;AACvDjB,IAAAA,OAAO,CAACC,cAAD,EAAiB,UAAjB,CAAP;AACD,GAnEwB;;AAqEzB;;;;;;;AAOAiB,EAAAA,eAAe,EAAE,UAAUjB,cAAV,EAA0BkB,YAA1B,EAAwC;AACvDnB,IAAAA,OAAO,CAACC,cAAD,EAAiB,UAAjB,CAAP;AACD,GA9EwB;;AAgFzB;;;;;;;AAOAmB,EAAAA,mBAAmB,EAAE,UAAUnB,cAAV,EAA0BoB,KAA1B,EAAiC;AACpDrB,IAAAA,OAAO,CAACC,cAAD,EAAiB,cAAjB,CAAP;AACD;AAzFwB,CAA3B;AA6FAqB,MAAM,CAACC,OAAP,GAAiBd,oBAAjB","sourcesContent":["/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactNoopUpdateQueue\n */\n\n'use strict';\n\nvar warning = require('fbjs/lib/warning');\n\nfunction warnTDZ(publicInstance, callerName) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nvar ReactNoopUpdateQueue = {\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @internal\n   */\n  enqueueCallback: function (publicInstance, callback) {},\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance) {\n    warnTDZ(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState) {\n    warnTDZ(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState) {\n    warnTDZ(publicInstance, 'setState');\n  },\n\n  /**\n   * Sets a subset of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialProps Subset of the next props.\n   * @internal\n   */\n  enqueueSetProps: function (publicInstance, partialProps) {\n    warnTDZ(publicInstance, 'setProps');\n  },\n\n  /**\n   * Replaces all of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} props New props.\n   * @internal\n   */\n  enqueueReplaceProps: function (publicInstance, props) {\n    warnTDZ(publicInstance, 'replaceProps');\n  }\n\n};\n\nmodule.exports = ReactNoopUpdateQueue;"]},"metadata":{},"sourceType":"script"}