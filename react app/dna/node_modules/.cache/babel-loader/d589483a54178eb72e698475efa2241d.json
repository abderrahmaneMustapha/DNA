{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMTextComponent\n * @typechecks static-only\n */\n'use strict';\n\nvar DOMChildrenOperations = require('./DOMChildrenOperations');\n\nvar DOMPropertyOperations = require('./DOMPropertyOperations');\n\nvar ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');\n\nvar ReactMount = require('./ReactMount');\n\nvar assign = require('./Object.assign');\n\nvar escapeTextContentForBrowser = require('./escapeTextContentForBrowser');\n\nvar setTextContent = require('./setTextContent');\n\nvar validateDOMNesting = require('./validateDOMNesting');\n/**\n * Text nodes violate a couple assumptions that React makes about components:\n *\n *  - When mounting text into the DOM, adjacent text nodes are merged.\n *  - Text nodes cannot be assigned a React root ID.\n *\n * This component is used to wrap strings in elements so that they can undergo\n * the same reconciliation that is applied to elements.\n *\n * TODO: Investigate representing React components in the DOM with text nodes.\n *\n * @class ReactDOMTextComponent\n * @extends ReactComponent\n * @internal\n */\n\n\nvar ReactDOMTextComponent = function (props) {// This constructor and its argument is currently used by mocks.\n};\n\nassign(ReactDOMTextComponent.prototype, {\n  /**\n   * @param {ReactText} text\n   * @internal\n   */\n  construct: function (text) {\n    // TODO: This is really a ReactText (ReactNode), not a ReactElement\n    this._currentElement = text;\n    this._stringText = '' + text; // Properties\n\n    this._rootNodeID = null;\n    this._mountIndex = 0;\n  },\n\n  /**\n   * Creates the markup for this text node. This node is not intended to have\n   * any features besides containing text content.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {string} Markup for this text node.\n   * @internal\n   */\n  mountComponent: function (rootID, transaction, context) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (context[validateDOMNesting.ancestorInfoContextKey]) {\n        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);\n      }\n    }\n\n    this._rootNodeID = rootID;\n\n    if (transaction.useCreateElement) {\n      var ownerDocument = context[ReactMount.ownerDocumentContextKey];\n      var el = ownerDocument.createElement('span');\n      DOMPropertyOperations.setAttributeForID(el, rootID); // Populate node cache\n\n      ReactMount.getID(el);\n      setTextContent(el, this._stringText);\n      return el;\n    } else {\n      var escapedText = escapeTextContentForBrowser(this._stringText);\n\n      if (transaction.renderToStaticMarkup) {\n        // Normally we'd wrap this in a `span` for the reasons stated above, but\n        // since this is a situation where React won't take over (static pages),\n        // we can simply return the text as it is.\n        return escapedText;\n      }\n\n      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';\n    }\n  },\n\n  /**\n   * Updates this component by updating the text content.\n   *\n   * @param {ReactText} nextText The next text content\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  receiveComponent: function (nextText, transaction) {\n    if (nextText !== this._currentElement) {\n      this._currentElement = nextText;\n      var nextStringText = '' + nextText;\n\n      if (nextStringText !== this._stringText) {\n        // TODO: Save this as pending props and use performUpdateIfNecessary\n        // and/or updateComponent to do the actual update for consistency with\n        // other component types?\n        this._stringText = nextStringText;\n        var node = ReactMount.getNode(this._rootNodeID);\n        DOMChildrenOperations.updateTextContent(node, nextStringText);\n      }\n    }\n  },\n  unmountComponent: function () {\n    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);\n  }\n});\nmodule.exports = ReactDOMTextComponent;","map":{"version":3,"sources":["C:/Users/icom/myProjects/DNA/react app/dna/node_modules/react-holder/node_modules/react/lib/ReactDOMTextComponent.js"],"names":["DOMChildrenOperations","require","DOMPropertyOperations","ReactComponentBrowserEnvironment","ReactMount","assign","escapeTextContentForBrowser","setTextContent","validateDOMNesting","ReactDOMTextComponent","props","prototype","construct","text","_currentElement","_stringText","_rootNodeID","_mountIndex","mountComponent","rootID","transaction","context","process","env","NODE_ENV","ancestorInfoContextKey","useCreateElement","ownerDocument","ownerDocumentContextKey","el","createElement","setAttributeForID","getID","escapedText","renderToStaticMarkup","createMarkupForID","receiveComponent","nextText","nextStringText","node","getNode","updateTextContent","unmountComponent","unmountIDFromEnvironment","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMTextComponent\n * @typechecks static-only\n */\n\n'use strict';\n\nvar DOMChildrenOperations = require('./DOMChildrenOperations');\nvar DOMPropertyOperations = require('./DOMPropertyOperations');\nvar ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');\nvar ReactMount = require('./ReactMount');\n\nvar assign = require('./Object.assign');\nvar escapeTextContentForBrowser = require('./escapeTextContentForBrowser');\nvar setTextContent = require('./setTextContent');\nvar validateDOMNesting = require('./validateDOMNesting');\n\n/**\n * Text nodes violate a couple assumptions that React makes about components:\n *\n *  - When mounting text into the DOM, adjacent text nodes are merged.\n *  - Text nodes cannot be assigned a React root ID.\n *\n * This component is used to wrap strings in elements so that they can undergo\n * the same reconciliation that is applied to elements.\n *\n * TODO: Investigate representing React components in the DOM with text nodes.\n *\n * @class ReactDOMTextComponent\n * @extends ReactComponent\n * @internal\n */\nvar ReactDOMTextComponent = function (props) {\n  // This constructor and its argument is currently used by mocks.\n};\n\nassign(ReactDOMTextComponent.prototype, {\n\n  /**\n   * @param {ReactText} text\n   * @internal\n   */\n  construct: function (text) {\n    // TODO: This is really a ReactText (ReactNode), not a ReactElement\n    this._currentElement = text;\n    this._stringText = '' + text;\n\n    // Properties\n    this._rootNodeID = null;\n    this._mountIndex = 0;\n  },\n\n  /**\n   * Creates the markup for this text node. This node is not intended to have\n   * any features besides containing text content.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {string} Markup for this text node.\n   * @internal\n   */\n  mountComponent: function (rootID, transaction, context) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (context[validateDOMNesting.ancestorInfoContextKey]) {\n        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);\n      }\n    }\n\n    this._rootNodeID = rootID;\n    if (transaction.useCreateElement) {\n      var ownerDocument = context[ReactMount.ownerDocumentContextKey];\n      var el = ownerDocument.createElement('span');\n      DOMPropertyOperations.setAttributeForID(el, rootID);\n      // Populate node cache\n      ReactMount.getID(el);\n      setTextContent(el, this._stringText);\n      return el;\n    } else {\n      var escapedText = escapeTextContentForBrowser(this._stringText);\n\n      if (transaction.renderToStaticMarkup) {\n        // Normally we'd wrap this in a `span` for the reasons stated above, but\n        // since this is a situation where React won't take over (static pages),\n        // we can simply return the text as it is.\n        return escapedText;\n      }\n\n      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';\n    }\n  },\n\n  /**\n   * Updates this component by updating the text content.\n   *\n   * @param {ReactText} nextText The next text content\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  receiveComponent: function (nextText, transaction) {\n    if (nextText !== this._currentElement) {\n      this._currentElement = nextText;\n      var nextStringText = '' + nextText;\n      if (nextStringText !== this._stringText) {\n        // TODO: Save this as pending props and use performUpdateIfNecessary\n        // and/or updateComponent to do the actual update for consistency with\n        // other component types?\n        this._stringText = nextStringText;\n        var node = ReactMount.getNode(this._rootNodeID);\n        DOMChildrenOperations.updateTextContent(node, nextStringText);\n      }\n    }\n  },\n\n  unmountComponent: function () {\n    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);\n  }\n\n});\n\nmodule.exports = ReactDOMTextComponent;"]},"metadata":{},"sourceType":"script"}